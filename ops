{"author":{"id":"b588886e8ed752fadf1299e138ac3436c5eb556ee8e02466cae19fa663a1a8d8"},"ops":[{"type":3,"timestamp":1716498294,"nonce":"PEc9wSfQTeBiZFVtbNdIY6CrpNQ=","metadata":{"github-id":"IC_kwDOLg8lJc5-1ve1","github-url":"https://github.com/roadster-rs/roadster/issues/154#issuecomment-2128017333"},"message":"Played around with this -- we don't _need_ the mock `AppContext`, and using a concrete `AppContext` instead does make some things cleaner. However, there are some pros and cons of each:\n\n### Concrete `AppContext`\n#### Cons\n1. Because the `redis_enqueue` field is not optional, we need to create a real `RedisPool`. We can create it without actually connecting to Redis, but it still needs to be called within the context of an async runtime, so any test that requires the `AppContext` would need to use `tokio::test`. This isn't a huge deal, I suppose...\n\n#### Pros\n1. Opposite of the mock `AppContext` cons, essentially\n\n### Mock `AppContext\n#### Cons\n1. Need to use `mockall_double` when importing `AppContext` whenever it's needed for tests. Also not a super big deal.\n2. Need to update the `mock!` anytime definitions in the `AppContext` impl change\n3. Code completion doesn't seem to be working -- `context.config()` doesn't show up, nor do the fields on the config.\n\n#### Pros \n1. Don't need to create a concrete redis pool, except for the few tests where it's needed.\n\n\nAlternatively, we can get the best of both worlds by mocking the `AppContextInner` instead of `AppContext`. This way, most of the code can use a concrete `AppContext`, and the inconveniences of using the mock `AppContextInner` struct are confined to the `AppContext` module.","files":null},{"type":4,"timestamp":1716502888,"nonce":"LY0kMe696sr0OIq9lwYxMbPgUJI=","metadata":{"github-id":"CE_lADOLg8lJc6J0GWuzwAAAAMB2dyi"},"status":2}]}