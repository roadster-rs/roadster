{"author":{"id":"b588886e8ed752fadf1299e138ac3436c5eb556ee8e02466cae19fa663a1a8d8"},"ops":[{"type":6,"timestamp":1739984542,"nonce":"217/Vub0rSk97XXeSHhyNew0TK0=","metadata":{"github-id":"UCE_lAHOLg8lJc6qs_CpznI6Ydw"},"target":"ac1bdd358d06b3796e22aaee445e0fbee41ec6f3728b1166c1fa58355c2ba64c","message":"Instead of creating a new docker image using test containers, we could potentially create a new db inside the existing container, similar to what [sqlx::test](https://docs.rs/sqlx/latest/sqlx/attr.test.html) does. This could be a potential speed up for tests compared to using test containers, which takes a couple seconds to start up for each test. \n\nThis is also the approach `loco` takes","files":null},{"type":3,"timestamp":1740005790,"nonce":"+8eBmo0jpJzLfLdUJnuK4IEmgpI=","metadata":{"github-id":"IC_kwDOLg8lJc6fJCq1","github-url":"https://github.com/roadster-rs/roadster/issues/634#issuecomment-2669947573"},"message":"Note that this requires the DB to be running, while the test containers approach only requires docker to be running.","files":null},{"type":3,"timestamp":1740013380,"nonce":"MUgR89zEgpEpW2wWKlOt6kw1SeM=","metadata":{"github-id":"IC_kwDOLg8lJc6fJuuk","github-url":"https://github.com/roadster-rs/roadster/issues/634#issuecomment-2670128036"},"message":"May need to run async code in Drop impl. If so, we should be able to do it like this: https://stackoverflow.com/questions/66035290/how-do-i-await-a-future-inside-a-non-async-method-which-was-called-from-an-async","files":null},{"type":3,"timestamp":1740129538,"nonce":"L+fdPYXPcn1giwb4nIWJ6NR2mPk=","metadata":{"github-id":"IC_kwDOLg8lJc6fYiwz","github-url":"https://github.com/roadster-rs/roadster/issues/634#issuecomment-2674011187"},"message":"We seem to be having some issues getting a “valid” connection from the pool (both diesel and seaorm I think). Do we need to get a standalone connection instead of using the pool? loco is using sqlx directly instead of the seaorm pool, maybe that’s why?\n\nDoes each database have a default table we can use in the connection we use to drop the test table? I’m not sure if it will help with the connection issue but we can try.","files":null},{"type":6,"timestamp":1740175127,"nonce":"5XQdkRLuXZN4BlFk0jVtTkhsUUY=","metadata":{"github-id":"UCE_lALOLg8lJc6fYiwzzl2Y3s8"},"target":"192fe853066d02d40a55397608d396816aeec749110eda5ffd40e94dc8520929","message":"We seem to be having some issues getting a “valid” connection from the pool (both diesel and seaorm I think). Do we need to get a standalone connection instead of using the pool? loco is using sqlx directly instead of the seaorm pool, maybe that’s why?\n\nDoes each database have a default table we can use in the connection we use to drop the test table? I’m not sure if it will help with the connection issue but we can try.\n\nWe can also try moving the DB drop logic to after the db connection pools are dropped. This would be done by adding a new field (that implements Drop) to the `AppContextInner` after the pool fields, which will cause it to be dropped after the pools.","files":null},{"type":6,"timestamp":1740195530,"nonce":"Mk9r1bH0H9M955NkseXXNN/NJcY=","metadata":{"github-id":"UCE_lALOLg8lJc6fYiwzzl2dVsU"},"target":"192fe853066d02d40a55397608d396816aeec749110eda5ffd40e94dc8520929","message":"We seem to be having some issues getting a “valid” connection from the pool (both diesel and seaorm I think). Do we need to get a standalone connection instead of using the pool? loco is using sqlx directly instead of the seaorm pool, maybe that’s why?\n\nUsing sqlx directly didn’t seem to help. However, non-async diesel is working (even with an async pool in the context). It also doesn’t seem to help to close the seaorm dbconnection first. Is it something to do with the test async runtime?\n\nDoes each database have a default table we can use in the connection we use to drop the test table? I’m not sure if it will help with the connection issue but we can try.\n\nWe can also try moving the DB drop logic to after the db connection pools are dropped. This would be done by adding a new field (that implements Drop) to the `AppContextInner` after the pool fields, which will cause it to be dropped after the pools.","files":null},{"type":3,"timestamp":1740206918,"nonce":"RNyii3lKvAEIa7oQBkwyn2PPrA8=","metadata":{"github-id":"IC_kwDOLg8lJc6fgWNB","github-url":"https://github.com/roadster-rs/roadster/issues/634#issuecomment-2676056897"},"message":"My current hunch is that it does have something to do with trying to run an async task while the tokio test runtime is shutting down. Is there a way to confirm this? Would using a [oneshot](https://docs.rs/tokio/1.43.0/tokio/sync/oneshot/index.html) help?","files":null},{"type":6,"timestamp":1740207323,"nonce":"7Uvfbc0pcMR914Y+ix+CZUFHwRI=","metadata":{"github-id":"UCE_lALOLg8lJc6fgWNBzl2ecdc"},"target":"96ff1a0e244f6da058b5426db13526d08129fa361b72b5efea01877c8d5aa6ae","message":"My current hunch is that it does have something to do with trying to run an async task while the tokio test runtime is shutting down. Is there a way to confirm this? Would using a [oneshot](https://docs.rs/tokio/1.43.0/tokio/sync/oneshot/index.html) help?\n\nA couple things that indicate this to me: \n- it’s working with non-async diesel connections and it wasn’t working with async diesel\n- spawned tokio tasks don’t seem to run","files":null},{"type":3,"timestamp":1740208079,"nonce":"xc2AoU8UzksGDnoGppC6iq28hmk=","metadata":{"github-id":"IC_kwDOLg8lJc6fgX4l","github-url":"https://github.com/roadster-rs/roadster/issues/634#issuecomment-2676063781"},"message":"Also looking at loco again, I forgot that they have a test hook thing where the test goes inside a lambda that’s provided to a function that sets up and tears stuff down. Maybe we need something like that? Basically, we would provide the prepared app the the lambda, then do clean up stuff after it completes, similar to how an app would normally be run.","files":null},{"type":4,"timestamp":1740314165,"nonce":"K7Vcd6IU4Ozcx3rKTBrMjYfzc+s=","metadata":{"github-id":"CE_lADOLg8lJc6qs_CpzwAAAAPSrgjq"},"status":2}]}